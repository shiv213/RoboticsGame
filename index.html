<!DOCTYPE html>
<html>

<head>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body onload="startGame()" id="script">
	<canvas id='c' style='position: absolute; left: 0px; top: 0px;'>
</canvas>
	<script>
		window.addEventListener('touchstart', function() {
			accelerate(-0.3);
		});
		window.addEventListener('touchend', function() {
			accelerate(0.2);
		});

		var myGamePiece;
		var myObstacles = [];
		var myScore;
		var score = 0;

		function startGame() {
			myGamePiece = new component(myGameArea.canvas.height * 0.15, myGameArea.canvas.height * 0.15, "red", 10, 120);
			myGamePiece.gravity = 0.05;
			myScore = new component("15px", "Oswald", "Blue", (c.width * 2) - (myGameArea.canvas.width * 0.1), 30, "text");
			myGameArea.start();
		}

		var myGameArea = {
			canvas: document.getElementById("c"),
			start: function() {
				this.canvas.width = window.innerWidth;
				this.canvas.height = window.innerHeight;
				this.context = this.canvas.getContext("2d");
				document.body.insertBefore(this.canvas, document.body.childNodes[0]);
				this.frameNo = 0;
				updateGameArea();
			},
			clear: function() {
				this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
			}
		}

		function component(width, height, color, x, y, type, turnAngle, randomSize) {
			this.type = type;
			this.score = 0;
			this.width = width;
			this.height = height;
			this.speedX = 0;
			this.speedY = 0;
			this.x = x;
			this.y = y;
			this.gravity = 0;
			this.gravitySpeed = 0;
			this.turnAngle = turnAngle;
			this.randomSize = randomSize;
			this.update = function() {
				ctx = myGameArea.context;
				if (this.type == "text") {
					ctx.font = this.width + " " + this.height;
					ctx.fillStyle = color;
					ctx.fillText(this.text, this.x, this.y);
				} else if (this.type == "Obstacles") {
					ctx.fillStyle = color;
					var finalxs = findCoordinatesX(this.width, this.height, this.x, this.y, this.randomSize, this.turnAngle);
					var finalys = findCoordinatesY(this.width, this.height, this.x, this.y, this.randomSize, this.turnAngle);

					ctx.beginPath();
					ctx.moveTo(finalxs[1], finalys[1]);
					ctx.lineTo(finalxs[0], finalys[0]);
					ctx.lineTo(finalxs[2], finalys[2]);
					ctx.lineTo(finalxs[3], finalys[3]);
					ctx.closePath();
					ctx.fill();
				} else if (this.type == "Coin") {

				} else {
					ctx.fillStyle = color;
					ctx.fillRect(this.x, this.y, this.width, this.height);
				}
			}
			this.newPos = function() {
				this.gravitySpeed += this.gravity;
				this.x += this.speedX;
				this.y += this.speedY + this.gravitySpeed;
				this.hitBottom();
				this.hitCelling();
			}
			this.hitBottom = function() {
				var rockbottom = myGameArea.canvas.height - this.height;
				if (this.y > rockbottom) {
					this.y = rockbottom;
					this.gravitySpeed = 0;
				}
			}
			this.hitCelling = function() {
				if (this.y < 0) {
					this.y = 0;
					this.gravitySpeed = 0;
				}
			}
			this.crashWith = function(otherobj) {
				var myleft = this.x;
				var myright = this.x + (this.width);
				var mytop = this.y;
				var mybottom = this.y + (this.height);
				var playerx = [myleft, myright, myright, myleft];
				var playery = [mytop, mytop, mybottom, mybottom];

				var width = otherobj.width;
				var height = otherobj.height;
				var randomSize = otherobj.randomSize;
				var turnAngle = otherobj.turnAngle;
				var x = otherobj.x;
				var y = otherobj.y;

				var finalxs = findCoordinatesX(width, height, x, y, randomSize, turnAngle);
				var finalys = findCoordinatesY(width, height, x, y, randomSize, turnAngle);

				for (var i = 0; i < 4; i++) {
					if (isPointInside(playerx[i], playery[i], finalxs, finalys)) {
						return true;
					}
				}

				for (var i = 0; i < 4; i++) {
					if (isPointInside(finalxs[i], finalys[i], playerx, playery)) {
						return true;
					}
				}
				return false;
			}
		}

		function isPointInside(px, py, rectanglexs, rectangleys) {
			var intersections = 0;
			for (var i = 0; i < 4; i++) {
				var nextPoint = i + 1;
				if (nextPoint == 4) nextPoint = 0;
				if (isHoriziontalToPointCrossingLine(px, py, rectanglexs[i], rectangleys[i], rectanglexs[nextPoint], rectangleys[nextPoint])) {
					intersections++;
				}
			}
			if (intersections % 2 == 1) {
				return true;
			}
			return false;
		}

		function isHoriziontalToPointCrossingLine(px, py, lx1, ly1, lx2, ly2) {
			var lineTop = Math.min(ly1, ly2);
			var lineBottom = Math.max(ly1, ly2);
			if ((py < lineBottom) && (py > lineTop)) {
				if (lx2 === lx1) {
					if (px > lx1) {
						return true;
					}
					return false;
				}
				var m = (ly2 - ly1) / (lx2 - lx1);
				var xOnLine = (py - ly2) / m + lx2;
				if (px >= xOnLine) {
					return true;
				}
			}
			return false
		}

		function updateGameArea() {
			var x, width, height, gap, minHeight, maxHeight, minGap, maxGap;
			for (i = 0; i < myObstacles.length; i += 1) {
				if (myGamePiece.crashWith(myObstacles[i])) {
					return;
				}
			}
			myGameArea.clear();
			myGameArea.frameNo += 1;
			speed = updateSpeed();
			var interval = Math.floor(200 / speed)
			if (myGameArea.frameNo == 1 || everyinterval(interval)) {
				x = myGameArea.canvas.width;
				var zones = Math.floor((Math.random() * 3))
				var randomness = (Math.random() * 0.3) + 0.7;
				height = Math.floor(Math.random() * (myGameArea.canvas.height * 0.1) + myGameArea.canvas.height * 0.3);
				width = myGameArea.canvas.height * 0.05;
				var turnInRads = makeToRad(Math.floor(Math.random() * 361));
				myObstacles.push(new component(width, height, "green", x, zones * (myGameArea.canvas.height * 0.33), "Obstacles", turnInRads, randomness));
			}
			for (i = 0; i < myObstacles.length; i += 1) {
				myObstacles[i].x += -speed;
				myObstacles[i].update();
			}
			if (myGameArea.frameNo == 1 || everyinterval(50)) {
				score += 1;
			}
			myScore.text = "SCORE: " + score;
			myScore.update();
			myGamePiece.newPos();
			myGamePiece.update();
			cleanObstacles();
		}

		function cleanObstacles() {
			for (var i = myObstacles.length - 1; i >= 0; i--) {
				if (myObstacles[i].x < -myGameArea.canvas.width) {
					myObstacles.splice(i, 1);
				}
			}
		}

		function everyinterval(n) {
			if ((myGameArea.frameNo / n) % 1 == 0) {
				return true;
			}
			return false;
		}

		function accelerate(n) {
			if (!myGameArea.interval) {
				myGameArea.interval = setInterval(updateGameArea, 15);
			}

			myGamePiece.gravity = n;
		}

		function makeToRad(Angle) {
			return ((Angle * Math.PI) / 180);
		}

		function findCenterX(width, x) {
			return ((width / 2) + x);
		}

		function findCenterY(height, y) {
			return ((height / 2) + y);
		}

		function getFinalX(x, y, centerX, centerY, turnAngle, my) {
			var mx = x - centerX;
			var my = y - centerY;
			var newmx = mx * Math.cos(turnAngle) - my * Math.sin(turnAngle);
			var finalx = newmx + centerX;
			return finalx;
		}

		function getFinalY(x, y, centerX, centerY, turnAngle, mx) {
			var mx = x - centerX;
			var my = y - centerY;
			var newmy = mx * Math.sin(turnAngle) + my * Math.cos(turnAngle);
			var finaly = newmy + centerY;
			return finaly;
		}

		function findCoordinatesX(width, height, x, y, randomSize, turnAngle) {
			var centerX = findCenterX(width, x);
			var centerY = findCenterY(height, y);
			var xs = [0, 0, 0, 0];
			var ys = [0, 0, 0, 0];

			xs[0] = x;
			xs[1] = x + (width * randomSize);
			xs[2] = x;
			xs[3] = x + (width * randomSize);

			ys[0] = y;
			ys[1] = y;
			ys[2] = y + (height * randomSize);
			ys[3] = y + (height * randomSize);

			var finalxs = [0, 0, 0, 0];
			var finalys = [0, 0, 0, 0];

			for (var i = 0; i < 4; i++) {
				finalxs[i] = getFinalX(xs[i], ys[i], centerX, centerY, turnAngle);
				finalys[i] = getFinalY(xs[i], ys[i], centerX, centerY, turnAngle);
			}
			return finalxs;
		}

		function findCoordinatesY(width, height, x, y, randomSize, turnAngle) {
			var centerX = findCenterX(width, x);
			var centerY = findCenterY(height, y);
			var xs = [0, 0, 0, 0];
			var ys = [0, 0, 0, 0];

			xs[0] = x;
			xs[1] = x + (width * randomSize);
			xs[2] = x;
			xs[3] = x + (width * randomSize);

			ys[0] = y;
			ys[1] = y;
			ys[2] = y + (height * randomSize);
			ys[3] = y + (height * randomSize);

			var finalxs = [0, 0, 0, 0];
			var finalys = [0, 0, 0, 0];

			for (var i = 0; i < 4; i++) {
				finalxs[i] = getFinalX(xs[i], ys[i], centerX, centerY, turnAngle);
				finalys[i] = getFinalY(xs[i], ys[i], centerX, centerY, turnAngle);
			}
			return finalys;
		}

		function updateSpeed() {
			return (0.05 * score) + 1;
		}

		function mouseDown() {
			accelerate(-0.2);
		}

		function mouseUp() {
			accelerate(0.1);
		}
	</script>
	<br>
</body>
</html>
